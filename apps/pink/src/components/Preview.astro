---
import Prism from "prismjs";
import Copy from "@components/Copy.astro";

const code = await Astro.slots.render("default");
const props = Astro.props;

let html: string = "";

if (Astro.slots.has("default")) {
  html = Prism.highlight(format(code), Prism.languages.html, "html");
}

/**
 * Receives a string and returns a wrapped string, with max
 * n characters per line, and a given indentation before each line.
 */
function wrapStr(str: string, n: number, indent: string): string {
  // remove line breaks and tabs
  str = str.replaceAll(/[\r\n\t]/g, "");
  const words = str.split(/\s/);
  const lines = words.reduce((acc, word) => {
    const lastLine = acc[acc.length - 1];

    if (acc.length === 0 || lastLine.length + word.length + 1 > n) {
      return [...acc, indent + word];
    }

    return [...acc.slice(0, -1), lastLine + " " + word];
  }, [] as string[]);

  return lines.join("\r");
}

function format(html: string) {
  let formatted = "";
  let indent = "";

  html.split(/>\s*</).forEach((element) => {
    // Decrease indent if line is a closing tag
    if (element.match(/^\/\w/)) indent = indent.substring(2);

    // By default, we just add the element with the current indent before it
    let toConcatenate = indent + "<" + element + ">\r";

    // If the element is too long, wrap its content
    const maxLineLength = 100;
    const contentMatch = element.match(/(.*?>)(.*?)(<.*)/s);
    if (contentMatch && toConcatenate.length > maxLineLength) {
      const [_, left, content, right] = contentMatch;
      toConcatenate =
        indent +
        "<" +
        left +
        "\n" +
        wrapStr(content, maxLineLength, indent + "  ") +
        "\r" +
        indent +
        right +
        ">\r";
    }

    formatted += toConcatenate;

    // Increase indent if element is a non-self-closing tag and not an input tag
    if (element.match(/^<?\w[^>]*[^\/]$/) && !element.startsWith("input")) {
      indent += "  ";
    }
  });

  return formatted.substring(1, formatted.length - 2);
}

//TODO: fix code example colors
---

<section
  class="common-section u-margin-block-start-36"
  x-data="{ show: 'prev' }"
>
  <div class="tabs">
    <ul class="tabs-list">
      <li class="tabs-item">
        <button
          class="tabs-button"
          x-on:click="show = 'prev'"
          :class="show === 'prev' ? 'is-selected' : ''"
        >
          <span class="text">Preview</span>
        </button>
      </li>
      <li class="tabs-item">
        <button
          class="tabs-button"
          x-on:click="show = 'html'"
          :class="show === 'html' ? 'is-selected' : '' "
        >
          <span class="text">HTML</span>
        </button>
      </li>
    </ul>
  </div>
  <div
    class="box u-margin-block-start-8"
    style="--box-border-radius:  var(--border-radius-medium);"
  >
    <template x-if="show === 'prev'">
      <div
        class:list={[
          "u-flex u-gap-32 u-flex-wrap",
          { "u-main-center": props?.center },
          { "u-flex-vertical": props?.vertical },
          { "u-cross-center": props?.vertical && props?.center },
        ]}
      >
        <slot />
      </div>
    </template>
    <template x-if="show === 'html'">
      <div class="u-padding-32">
        <Copy value={code} client:load />
        <pre>
<code class="language-html withLineNumbers" set:html={html} />
        </pre>
      </div>
    </template>
  </div>
</section>
